<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>FOUDEK â€“ ThÃ©orie et calculs</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
body {
  margin: 0;
  padding: 0;
  background: #0e0f14;
  color: #e6e7eb;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI",
               Roboto, Oxygen, Ubuntu, Cantarell, "Inter", sans-serif;
  line-height: 1.6;
}

.container {
  max-width: 900px;
  margin: auto;
  padding: 40px 20px;
}

h1, h2, h3 {
  text-align: center;
  font-weight: 700;
}

h1 {
  font-size: 30px;
  margin-bottom: 40px;
}

h2 {
  font-size: 24px;
  margin: 50px 0 20px;
}

p {
  margin: 16px 0;
  font-size: 16px;
}

ul {
  margin: 16px 0 16px 20px;
}

li {
  margin: 8px 0;
}

.separator {
  height: 1px;
  background: #2a2c36;
  margin: 50px 0;
}

.formula {
  background: #1a1c25;
  border-radius: 8px;
  padding: 14px 18px;
  font-family: "JetBrains Mono", Consolas, monospace;
  font-size: 15px;
  overflow-x: auto;
  margin: 20px 0;
  text-align: center;
}

.cards {
  display: flex;
  gap: 20px;
  flex-wrap: wrap;
  justify-content: center;
  margin-top: 40px;
}

.card {
  background: #0e0f14;
  border: 1px solid #2a2c36;
  border-radius: 14px;
  padding: 20px;
  width: 300px;
}

.card.blue {
  box-shadow: 0 0 18px rgba(37, 99, 235, 0.35);
}

.card.red {
  box-shadow: 0 0 18px rgba(220, 38, 38, 0.35);
}

label {
  display: block;
  margin-top: 12px;
  font-size: 14px;
}

input, textarea {
  width: 100%;
  margin-top: 6px;
  padding: 8px;
  background: #0e0f14;
  border: 1px solid #3a3d4d;
  border-radius: 6px;
  color: #e6e7eb;
}

button {
  width: 100%;
  margin-top: 16px;
  padding: 10px;
  border: none;
  border-radius: 6px;
  background: #2563eb;
  color: white;
  font-weight: bold;
  cursor: pointer;
}

.result {
  margin-top: 15px;
  padding: 10px;
  border-radius: 999px;
  text-align: center;
  font-weight: bold;
  opacity: 0.35;
  transition: opacity 0.3s, box-shadow 0.3s;
}

.result.blue {
  background: #1d4ed8;
}

.result.red {
  background: #dc2626;
}

.result.active {
  opacity: 1;
  box-shadow: 0 0 20px rgba(255,255,255,0.25);
}
</style>
</head>

<body>
<div class="container">

<h1>FOUDEK â€“ ThÃ©orie et probabilitÃ© hors intervalle</h1>

<h2>Pourquoi il nâ€™y a jamais plus de 1 loup sur 4</h2>

<p>
Dans la thÃ©orie FOUDEK, on part du principe que lorsquâ€™un joueur raisonne
inconsciemment, il suppose presque toujours quâ€™il existe au moins un loup
en dehors dâ€™un groupe suspect.
</p>

<p>
Les discussions, les Ã©changes directs entre deux joueurs ou la formation
de plusieurs conversations parallÃ¨les peuvent suggÃ©rer lâ€™existence
de plusieurs intervalles distincts, sans jamais impliquer quâ€™un seul
groupe concentre une majoritÃ© de loups.
</p>

<p>
Les votes jouent un rÃ´le central : lorsquâ€™un vote relie deux joueurs,
il crÃ©e un intervalle logique. Plusieurs votes peuvent fusionner ces
intervalles, mais dÃ©passer 1 loup sur 4 rendrait toute stratÃ©gie
rationnelle impossible pour un innocent.
</p>

<p>
Les triangles de vote (A vote C, C vote D, D vote A) renforcent cette
intuition : mÃªme dans ces structures fermÃ©es, lâ€™hypothÃ¨se de plus de
1 loup sur 3 conduit Ã  une incohÃ©rence probabiliste. La thÃ©orie FOUDEK
exclut donc ces mondes par construction.
</p>

<div class="separator"></div>

<h2>DÃ©tail du calcul de la probabilitÃ© hors intervalle</h2>

<ul>
  <li><strong>I</strong> : joueurs dans lâ€™intervalle</li>
  <li><strong>R</strong> : joueurs hors intervalle</li>
  <li><strong>L</strong> : loups vivants</li>
  <li><strong>k</strong> : loups dans lâ€™intervalle</li>
</ul>

<div class="formula">C(I, k) Ã— C(R, L âˆ’ k)</div>
<div class="formula">(L âˆ’ k) / R</div>

<div class="separator"></div>

<h2>Ã‰quation universelle finale</h2>

<div class="formula">
P<sub>R</sub> =
Î£<sub>k = 0</sub><sup>1</sup>
(
C(I, k) Â· C(R, L âˆ’ k)
/
Î£<sub>i = 0</sub><sup>1</sup>
C(I, i) Â· C(R, L âˆ’ i)
)
Ã— (L âˆ’ k) / R
</div>

<div class="separator"></div>

<h2>Calcul de probabilitÃ©</h2>

<div class="cards">
<div class="card blue">
<h3>ðŸ”µ MÃ©thode FOUDEK</h3>
<label>I</label><input id="I1" type="number">
<label>R</label><input id="R1" type="number">
<label>L</label><input id="L1" type="number">
<button onclick="calcFoudek()">Calculer</button>
<div id="resF" class="result blue">â€”</div>
</div>

<div class="card red">
<h3>ðŸ”´ MÃ©thode classique</h3>
<label>I</label><input id="I2" type="number">
<label>R</label><input id="R2" type="number">
<label>L</label><input id="L2" type="number">
<button onclick="calcClassic()">Calculer</button>
<div id="resC" class="result red">â€”</div>
</div>
</div>

<div class="separator"></div>

<h2>ðŸ¤– Mini-IA FOUDEK (analyse textuelle)</h2>

<p>
DÃ©cris les votes avec des pseudos. Lâ€™IA reconstruit automatiquement
les intervalles et applique exactement les mÃªmes algorithmes.
</p>

<div class="card">
<textarea id="aiInput" rows="6"
placeholder="ex :
zytronx vote kader
keraod vote medna"></textarea>

<label>Nombre total de joueurs (sans vous)</label>
<input id="aiN" type="number" value="7">

<label>Loups vivants</label>
<input id="aiL" type="number" value="2">

<button onclick="runAI()">Analyser</button>

<div id="aiResF" class="result blue">FOUDEK : â€”</div>
<div id="aiResC" class="result red">Classique : â€”</div>
</div>

</div>

<script>
// Combinaison
function C(n, k) {
  if (k < 0 || k > n) return 0;
  let r = 1;
  for (let i = 1; i <= k; i++) r *= (n - i + 1) / i;
  return r;
}

function calcFoudek() {
  const I = +I1.value, R = +R1.value, L = +L1.value;
  let n = 0, d = 0;
  for (let k = 0; k <= 1; k++) {
    if (k > L || L - k > R) continue;
    const c = C(I, k) * C(R, L - k);
    d += c; n += c * ((L - k) / R);
  }
  resF.textContent = ((n / d) * 100).toFixed(1) + " %";
  resF.classList.add("active");
}

function calcClassic() {
  const I = +I2.value, R = +R2.value, L = +L2.value;
  let n = 0, d = 0;
  for (let k = 0; k <= 2; k++) {
    if (k > L || L - k > R) continue;
    const c = C(I, k) * C(R, L - k);
    d += c; n += c * ((L - k) / R);
  }
  resC.textContent = ((n / d) * 100).toFixed(1) + " %";
  resC.classList.add("active");
}

function runAI() {
  const text = aiInput.value.toLowerCase().trim().split("\n");
  const N = +aiN.value, L = +aiL.value;

  let intervals = [];

  text.forEach(line => {
    const clean = line.replace(/\s+/g, " ").trim();
    const m = clean.match(/^(.+?) vote (.+)$/);
    if (!m) return;
    intervals.push(new Set([m[1], m[2]]));
  });

  let merged = [];
  intervals.forEach(s => {
    let added = false;
    for (let m of merged) {
      if ([...s].some(x => m.has(x))) {
        s.forEach(x => m.add(x));
        added = true;
        break;
      }
    }
    if (!added) merged.push(new Set(s));
  });

  let I = merged.reduce((a, s) => a + s.size, 0);
  let R = N - I;

  let nF = 0, dF = 0;
  for (let k = 0; k <= 1; k++) {
    if (k > L || L - k > R) continue;
    const c = C(I, k) * C(R, L - k);
    dF += c; nF += c * ((L - k) / R);
  }

  let nC = 0, dC = 0;
  for (let k = 0; k <= 2; k++) {
    if (k > L || L - k > R) continue;
    const c = C(I, k) * C(R, L - k);
    dC += c; nC += c * ((L - k) / R);
  }

  aiResF.textContent = "FOUDEK : " + ((nF / dF) * 100).toFixed(1) + " %";
  aiResC.textContent = "Classique : " + ((nC / dC) * 100).toFixed(1) + " %";
  aiResF.classList.add("active");
  aiResC.classList.add("active");
}
</script>

</body>
</html>